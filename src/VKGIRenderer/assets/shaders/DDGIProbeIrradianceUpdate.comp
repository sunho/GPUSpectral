#version 450

#pragma shader_stage(compute)

#define FIXED_POINT_PRECISION 1024

#extension GL_GOOGLE_include_directive : require
#include "common.glsl"
layout (local_size_x = IRD_MAP_TEX_SIZE, local_size_y = IRD_MAP_TEX_SIZE) in;

#extension GL_KHR_shader_subgroup_ballot: require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "probe.glsl"

layout(std140, set=0, binding = 0) buffer RayBuffer {
    Ray rays[];
} rayBuffer;

layout(set=1,binding = 0) uniform sampler2D radianceBuffer;
layout(set=1,binding = 1) uniform sampler2D distanceBuffer;
layout (set=2,binding = 0, rgba16f) uniform image2D irradianceMap;

shared int sampleCount;
shared ivec4 reducedIrradiance;
shared int reducedDist;
shared int reducedDistSquare;

void main() {
    int probeID = int(gl_WorkGroupID.x);
    ivec2 iuv = ivec2(gl_LocalInvocationID.x, gl_LocalInvocationID.y);
    ivec2 iiuv = iuv - IRD_MAP_BORDER;
    if (iiuv.x < 0 || iiuv.y < 0 || iiuv.x >= IRD_MAP_SIZE || iiuv.y >= IRD_MAP_SIZE) {
        iiuv = iiuv % ivec2(IRD_MAP_SIZE, IRD_MAP_SIZE);
        iiuv = ivec2(IRD_MAP_SIZE, IRD_MAP_SIZE) - iiuv;
    }
    vec2 uv = vec2(iiuv) / IRD_MAP_SIZE;
    vec3 dir = octahedronReverseMap(uv);
    vec4 sumIrradiance = vec4(0.0);
    float sumWeight = 0.0;
    for (int i = 0; i < RAYS_PER_PROBE; i++) {
        uint rayID = i;
        Ray ray = rayBuffer.rays[probeID * RAYS_PER_PROBE + rayID];
        vec4 radiance = texelFetch(radianceBuffer, ivec2(rayID, probeID), 0);
        float dist = texelFetch(distanceBuffer, ivec2(rayID, probeID), 0).x;
        if (dist == 0.0) {
            radiance = vec4(0.3);
        }
        float weight = max(0.0, dot(dir, ray.dir));
        sumIrradiance += weight * radiance;
        sumWeight += weight;
    }
    if (sumWeight < 0.02) return;
    vec4 irradiance = sumIrradiance / RAYS_PER_PROBE;
    irradiance *= 2.0 * M_PI; // inverse of pdf which is stradian of unit sphere
    irradiance.a = 1.0;
    ivec2 startOffset = probeIDToIRDTexOffset(probeID);
    ivec2 storeUv = startOffset + iuv;
    vec4 bb = imageLoad(irradianceMap, storeUv);
    if (bb == vec4(0.0)) {
        imageStore(irradianceMap, storeUv, irradiance);
    } else {
        imageStore(irradianceMap, storeUv, mix(bb,irradiance, 0.03));
    }
   
}