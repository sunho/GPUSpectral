#version 450

#define RAYS_PER_PROBE 256
#define MAX_DIFFUSE_MAPS 32

layout (local_size_x = RAYS_PER_PROBE) in;
#extension GL_GOOGLE_include_directive : require

#include "common.glsl"

#include "probe.glsl"

struct RayShaded {
    vec3 radiance;
    float dist;
};

layout(std140, binding = 0) uniform SceneBuffer {
    uvec2 frameSize;
    uint instanceNum;
    Instance instances[MAX_INSTANCES];
    uvec3 gridNum;
    vec3 sceneSize;
} sceneBuffer;

layout(std140,set=1,binding = 0) readonly buffer VertexBuffer {
    Vertex vertices[];
} vertexBuffer;

layout(std140,set=1,binding = 1) readonly buffer RayHitBuffer {
    RayHit hits[];
} rayHitBuffer;

layout (set=2,binding = 0, rgba16f) uniform writeonly image2D positionBuffer;
layout (set=2,binding = 1, rgba16f) uniform writeonly image2D normalBuffer;
layout (set=2,binding = 2, rgba16f) uniform writeonly image2D diffuseBuffer;
layout (set=2,binding = 3, rgba16f) uniform writeonly image2D distanceBuffer;
layout (set=2,binding = 4) uniform sampler2D diffuseMap[MAX_DIFFUSE_MAPS];

void main() {
    uint gID = gl_GlobalInvocationID.x;
    uint probeID = gID / RAYS_PER_PROBE;
    uint rayID = gID % RAYS_PER_PROBE;
    RayHit hit = rayHitBuffer.hits[gID];
    ivec2 outCoord = ivec2(rayID,probeID);
    if (hit.instId == 0xFFFFFFFF) {
        imageStore(distanceBuffer, outCoord, vec4(0.0));
        imageStore(normalBuffer, outCoord, vec4(0.0));
        imageStore(positionBuffer, outCoord, vec4(0.0));
        imageStore(diffuseBuffer, outCoord, vec4(0.0));
    } else {
        Instance instance = sceneBuffer.instances[hit.instId];
        Vertex v0 = vertexBuffer.vertices[instance.vertexStart + hit.primId * 3];
        Vertex v1 = vertexBuffer.vertices[instance.vertexStart + hit.primId * 3 + 1];
        Vertex v2 = vertexBuffer.vertices[instance.vertexStart + hit.primId * 3 + 2];
        vec3 n0 = vec3(instance.transform * vec4(v0.normal, 0.0));
        vec3 n1 = vec3(instance.transform * vec4(v1.normal, 0.0));
        vec3 n2 = vec3(instance.transform * vec4(v2.normal, 0.0));
        vec3 p0 = vec3(instance.transform * vec4(v0.pos, 1.0));
        vec3 p1 = vec3(instance.transform * vec4(v1.pos, 1.0));
        vec3 p2 = vec3(instance.transform * vec4(v2.pos, 1.0));
        vec3 bary = vec3(hit.bary,1.0-(hit.bary.x+hit.bary.y));
        vec3 nor = normalize(bary.x * n1 + bary.y * n2 + bary.z * n0);
        vec3 pos = bary.x * p1 + bary.y * p2 + bary.z * p0;
        vec2 uv = bary.x * v1.uv + bary.y * v2.uv + bary.z * v0.uv;
        float dist = distance(probeIDToPos(probeID, sceneBuffer.gridNum, sceneBuffer.sceneSize), pos);
        imageStore(distanceBuffer, outCoord, vec4(dist));
        imageStore(normalBuffer, outCoord, vec4(nor,0.0));
        imageStore(positionBuffer, outCoord, vec4(pos,0.0));
        vec4 diffuse = texture(diffuseMap[instance.diffuseMapIndex], uv);
        imageStore(diffuseBuffer, outCoord, diffuse);
    }
}
