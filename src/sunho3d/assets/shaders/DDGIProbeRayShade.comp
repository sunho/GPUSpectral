#version 450
#pragma shader_stage(compute)

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require

#include "common.glsl"
#include "probe.glsl"

layout (local_size_x = RAYS_PER_PROBE) in;

struct RayShaded {
    vec3 radiance;
    float dist;
};

layout(std140, binding = 0) uniform SceneBuffer {
    uvec2 frameSize;
    uint instanceNum;
    Instance instances[MAX_INSTANCES];
    SceneInfo sceneInfo;
} sceneBuffer;

layout(std430,set=1,binding = 0) buffer VertexPositionBuffer {
    float position[];
} vertexPositionBuffer[MAX_MESH_COUNT];

layout(std430,set=1,binding = 1) buffer VertexNormalBuffer {
    float normal[];
} vertexNormalBuffer[MAX_MESH_COUNT];

layout(std430,set=1,binding = 2) buffer VertexUVBuffer {
    float uv[];
} vertexUVBuffer[MAX_MESH_COUNT];

layout(std140,set=1,binding = 3) readonly buffer RayHitBuffer {
    RayHit hits[];
} rayHitBuffer;

layout (set=2,binding = 0, rgba16f) uniform writeonly image2D positionBuffer;
layout (set=2,binding = 1, rgba16f) uniform writeonly image2D normalBuffer;
layout (set=2,binding = 2, rgba16f) uniform writeonly image2D diffuseBuffer;
layout (set=2,binding = 3, rgba16f) uniform writeonly image2D emissionBuffer;
layout (set=2,binding = 4, rgba16f) uniform writeonly image2D distanceBuffer;
layout (set=2,binding = 5) uniform sampler2D diffuseMap[MAX_DIFFUSE_MAPS];

Vertex loadVertex(int meshIndex, uint faceIndex) {
    Vertex v;
    v.pos = vec3(vertexPositionBuffer[nonuniformEXT(meshIndex)].position[faceIndex*3],
                      vertexPositionBuffer[nonuniformEXT(meshIndex)].position[faceIndex*3 + 1],
                      vertexPositionBuffer[nonuniformEXT(meshIndex)].position[faceIndex*3 + 2]);
    v.normal = vec3(vertexNormalBuffer[nonuniformEXT(meshIndex)].normal[faceIndex*3],
                          vertexNormalBuffer[nonuniformEXT(meshIndex)].normal[faceIndex*3 + 1],
                          vertexNormalBuffer[nonuniformEXT(meshIndex)].normal[faceIndex*3 + 2]);
    v.uv = vec2(vertexUVBuffer[nonuniformEXT(meshIndex)].uv[faceIndex*2],
                      vertexUVBuffer[nonuniformEXT(meshIndex)].uv[faceIndex*2 + 1]);
    return v;
}

void main() {
    int probeID = int(gl_WorkGroupID.x);
    uint rayID = gl_LocalInvocationID.x;
    RayHit hit = rayHitBuffer.hits[probeID * RAYS_PER_PROBE + rayID];
    ivec2 outCoord = ivec2(rayID,probeID);
    if (hit.instId == 0xFFFFFFFF) {
        imageStore(distanceBuffer, outCoord, vec4(0.0));
        imageStore(normalBuffer, outCoord, vec4(0.0));
        imageStore(positionBuffer, outCoord, vec4(0.0));
        imageStore(emissionBuffer, outCoord, vec4(0.0));
        imageStore(diffuseBuffer, outCoord, vec4(0.0));
    } else {
        Instance instance = sceneBuffer.instances[hit.instId];
        Vertex v0 = loadVertex(instance.meshIndex, hit.primId * 3);
        Vertex v1 = loadVertex(instance.meshIndex, hit.primId * 3 + 1);
        Vertex v2 = loadVertex(instance.meshIndex, hit.primId * 3 + 2);
        mat4 invModelT = transpose(inverse(instance.transform));
        vec3 n0 = vec3(invModelT * vec4(v0.normal, 0.0));
        vec3 n1 = vec3(invModelT * vec4(v1.normal, 0.0));
        vec3 n2 = vec3(invModelT  * vec4(v2.normal, 0.0));
        vec3 p0 = vec3(instance.transform * vec4(v0.pos, 1.0));
        vec3 p1 = vec3(instance.transform * vec4(v1.pos, 1.0));
        vec3 p2 = vec3(instance.transform * vec4(v2.pos, 1.0));
        vec3 bary = vec3(hit.bary,1.0-(hit.bary.x+hit.bary.y));
        vec3 nor = normalize(bary.x * n1 + bary.y * n2 + bary.z * n0);
        vec3 pos = bary.x * p1 + bary.y * p2 + bary.z * p0;
        vec2 uv = bary.x * v1.uv + bary.y * v2.uv + bary.z * v0.uv;
        float dist = distance(probeIDToPos(probeID, sceneBuffer.sceneInfo), pos);
        imageStore(distanceBuffer, outCoord, vec4(dist));
        imageStore(normalBuffer, outCoord, vec4(nor,0.0));
        imageStore(positionBuffer, outCoord, vec4(pos,0.0));
        vec4 diffuse = vec4(0.0);
        vec4 emission = vec4(0.0);
        Material material = sceneBuffer.instances[hit.instId].material;
        if (material.typeID == MATERIAL_DIFFUSE_COLOR) {
            diffuse = vec4(material.diffuseColor, 1.0);
        } else if (material.typeID == MATERIAL_DIFFUSE_TEXTURE) {
            diffuse = texture(diffuseMap[material.diffuseMapIndex], uv);
        } else {
            emission = vec4(material.diffuseColor, 1.0);
        }
        imageStore(diffuseBuffer, outCoord, diffuse);
        imageStore(emissionBuffer, outCoord, emission);
    }
}
